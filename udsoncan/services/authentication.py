from __future__ import annotations
from typing import ClassVar, Optional
import struct
from enum import IntEnum
from dataclasses import dataclass
from udsoncan.request import Request
from udsoncan.response import Response
from udsoncan.base_service import (
    BaseService,
    BaseSubfunction,
    ServiceData,
    uds_field,
)
from udsoncan.exceptions import *
from udsoncan.response_code import ResponseCode
from udsoncan.standards import StandardVersion
import udsoncan.tools as tools


class AuthenticationTask(IntEnum):
    deAuthenticate = 0
    verifyCertificateUnidirectional = 1
    verifyCertificateBidirectional = 2
    proofOfOwnership = 3
    transmitCertificate = 4
    requestChallengeForAuthentication = 5
    verifyProofOfOwnershipUnidirectional = 6
    verifyProofOfOwnershipBidirectional = 7
    authenticationConfiguration = 8


# shorter alias for internal readability
_SubFn = AuthenticationTask
_ALL_SUBFN = list(AuthenticationTask.__members__.values())


class AuthenticationReturnParameter(IntEnum):
    RequestAccepted = 0x00
    GeneralReject = 0x01
    AuthenticationConfiguration_APCE = 0x02
    AuthenticationConfiguration_ACR_with_asymmetric_cryptography = 0x03
    AuthenticationConfiguration_ACR_with_symmetric_cryptography = 0x04

    DeAuthentication_successful = 0x10
    CertificateVerified_OwnershipVerificationNecessary = 0x11
    OwnershipVerified_AuthenticationComplete = 0x12
    CertificateVerified = 0x13


@dataclass
class RequestData(ServiceData):
    """
    .. data:: authentication_task_echo
        Authentication Task echoed back by the server

    .. data:: return_value
        :ref:`AuthenticationReturnParameter<AuthenticationReturnParameter>` authenticationReturnParameter as defined in
            B.5. (ISO 14229-1:2020)

    .. data:: challenge_server
        The challenge contains vehicle manufacturer specific formatted server data (eventually containing randomized
        information) or is a random number.

    .. data:: ephemeral_public_key_server
        Ephemeral public key generated by the server for Diffie-Hellman key agreement.

    .. data:: certificate_server
        The Certificate to verify.

    .. data:: proof_of_ownership_server
        Proof of Ownership to be verified by the client.

    .. data:: session_key_info
        If present, this value shall contain session key information, e.g. the encrypted session key(s) for securing
        further communication in the actual session and/or proof value(s) (e.g. a hash value) for the validation of the
        session key(s) on the client side.

    .. data:: algorithm_indicator
        Indicates the algorithm used in the generating and verifying Proof of Ownership (POWN), which further determines
        the parameters used in the algorithm and possibly the session key creation mode. This field is a 16 byte value
        containing the BER encoded OID value of the algorithm used. The value is left aligned and right padded with
        zero up to 16 bytes.

    .. data:: needed_additional_parameter
        Indicate what additional parameters, if needed, are expected by the server.
    """

    SupportedSubFunctions: ClassVar[type[IntEnum] | None] = AuthenticationTask
    communication_configuration: bytes = uds_field(
        b"\x00",
        "c",
        subfunctions=[
            _SubFn.verifyCertificateUnidirectional,
            _SubFn.requestChallengeForAuthentication,
        ],
    )
    # verifyCertificateUnidirectional / verifyCertificateBidirectional
    certificate_client: bytes = uds_field(
        b"",
        "h{}s",
        subfunctions=[
            _SubFn.verifyCertificateUnidirectional,
            _SubFn.verifyCertificateBidirectional,
        ],
    )
    challenge_client: bytes = uds_field(
        b"",
        "h{}s",
        subfunctions=[
            _SubFn.verifyCertificateUnidirectional,
            _SubFn.verifyCertificateBidirectional,
        ],
    )
    # proofOfOwnership
    proof_of_ownership_client: bytes = uds_field(
        b"", "h{}s", subfunctions=_SubFn.proofOfOwnership
    )
    ephemeral_public_key_client: bytes = uds_field(
        b"", "h{}s", subfunctions=_SubFn.proofOfOwnership
    )

    # transmitCertificate
    certificate_evaluation_id: int = uds_field(
        0, "h", subfunctions=_SubFn.transmitCertificate
    )
    certificate_data: bytes = uds_field(
        b"", "h{}s", subfunctions=_SubFn.transmitCertificate
    )
    # requestChallengeForAuthentication.
    algorithm_indicator: bytes = uds_field(
        b"\x00" * 16,
        "16s",
        subfunctions=[
            _SubFn.requestChallengeForAuthentication,
            _SubFn.verifyProofOfOwnershipUnidirectional,
            _SubFn.verifyProofOfOwnershipBidirectional,
        ],
    )
    # verifyProofOfOwnershipUnidirectional / verifyProofOfOwnershipBidirectional
    proof_of_ownership_client: bytes = uds_field(
        b"",
        "h{}s",
        subfunctions=[
            _SubFn.verifyProofOfOwnershipUnidirectional,
            _SubFn.verifyProofOfOwnershipBidirectional,
        ],
    )
    challenge_client: bytes = uds_field(
        b"",
        "h{}s",
        subfunctions=[
            _SubFn.verifyCertificateUnidirectional,
            _SubFn.verifyProofOfOwnershipUnidirectional,
            _SubFn.verifyProofOfOwnershipBidirectional,
        ],
    )
    additional_parameter: bytes = uds_field(
        b"",
        "h{}s",
        subfunctions=[
            _SubFn.verifyCertificateUnidirectional,
            _SubFn.verifyProofOfOwnershipUnidirectional,
            _SubFn.verifyProofOfOwnershipBidirectional,
        ],
    )


@dataclass
class ResponseData(ServiceData):
    SupportedSubFunctions: ClassVar[type[IntEnum] | None] = AuthenticationTask
    return_value: AuthenticationReturnParameter = uds_field(
        AuthenticationReturnParameter.RequestAccepted,
        "c",
        subfunctions=_ALL_SUBFN,
    )
    algorithm_indicator: bytes = uds_field(
        b"\x00" * 16,
        "16s",
        subfunctions=[
            _SubFn.requestChallengeForAuthentication,
            _SubFn.verifyProofOfOwnershipUnidirectional,
            _SubFn.verifyProofOfOwnershipBidirectional,
        ],
    )

    challenge_server: bytes = uds_field(
        b"",
        "h{}s",
        subfunctions=[
            _SubFn.verifyCertificateUnidirectional,
            _SubFn.verifyCertificateBidirectional,
            _SubFn.requestChallengeForAuthentication,
        ],
    )
    needed_additional_parameter: bytes = uds_field(
        b"",
        "h{}s",
        subfunctions=_SubFn.requestChallengeForAuthentication,
    )
    certificate_server: bytes = uds_field(
        b"", "h{}s", subfunctions=[_SubFn.verifyCertificateBidirectional]
    )

    # verifyCertificateUnidirectional
    proof_of_ownership_server: bytes = uds_field(
        b"",
        "h{}s",
        subfunctions=[
            _SubFn.verifyCertificateBidirectional,
            _SubFn.verifyProofOfOwnershipBidirectional,
        ],
    )
    session_key_info: bytes = uds_field(
        b"",
        "h{}s",
        subfunctions=[
            _SubFn.proofOfOwnership,
            _SubFn.verifyProofOfOwnershipUnidirectional,
            _SubFn.verifyProofOfOwnershipBidirectional,
        ],
    )
    ephemeral_public_key_server: bytes = uds_field(
        b"",
        "h{}s",
        subfunctions=[
            _SubFn.verifyCertificateUnidirectional,
            _SubFn.verifyCertificateBidirectional,
        ],
    )


class Authentication(BaseService):
    _sid = 0x29

    supported_negative_response = [
        ResponseCode.SubFunctionNotSupported,
        ResponseCode.IncorrectMessageLengthOrInvalidFormat,
        ResponseCode.ConditionsNotCorrect,
        ResponseCode.RequestSequenceError,
        ResponseCode.CertificateVerificationFailed_InvalidTimePeriod,
        ResponseCode.CertificateVerificationFailed_InvalidSignature,
        ResponseCode.CertificateVerificationFailed_InvalidChainOfTrust,
        ResponseCode.CertificateVerificationFailed_InvalidType,
        ResponseCode.CertificateVerificationFailed_InvalidFormat,
        ResponseCode.CertificateVerificationFailed_InvalidContent,
        ResponseCode.CertificateVerificationFailed_InvalidScope,
        ResponseCode.CertificateVerificationFailed_InvalidCertificate,
        ResponseCode.OwnershipVerificationFailed,
        ResponseCode.ChallengeCalculationFailed,
        ResponseCode.SettingAccessRightsFailed,
        ResponseCode.SessionKeyCreationDerivationFailed,
        ResponseCode.ConfigurationDataUsageFailed,
        ResponseCode.DeAuthenticationFailed,
    ]

    @classmethod
    def get_request_cls(
        cls, standard_version: StandardVersion = StandardVersion.latest()
    ) -> type[ServiceData]:
        """
        Main dispatcher for service classes.
        Service classes should override appropriately.
        Provides the appropriate dataclass to use for the request for the requested standard version.
        If standard version is irrelevant it may be simply ignored.

        Returns
        -------
        type[ServiceData]
            The class to use for the request payload
        """
        return RequestData

    @classmethod
    def get_response_cls(
        cls, standard_version: StandardVersion = StandardVersion.latest()
    ) -> type[ServiceData]:
        """
        Main dispatcher for service classes.
        Service classes should override appropriately.
        Provides the appropriate dataclass to use for the response for the requested standard version.
        If standard version is irrelevant it may be simply ignored.

        Returns
        -------
        type[ServiceData]
            The class to use for the response payload
        """
        return ResponseData

    class AuthenticationTask(BaseSubfunction):
        __pretty_name__ = "authentication task"

        deAuthenticate = 0
        verifyCertificateUnidirectional = 1
        verifyCertificateBidirectional = 2
        proofOfOwnership = 3
        transmitCertificate = 4
        requestChallengeForAuthentication = 5
        verifyProofOfOwnershipUnidirectional = 6
        verifyProofOfOwnershipBidirectional = 7
        authenticationConfiguration = 8

    @staticmethod
    def _append_byes_parameter(
        data: bytes, parameter: Optional[bytes], parameter_name: str
    ) -> bytes:
        if parameter is not None:
            if not isinstance(parameter, bytes):
                raise ValueError(f"{parameter_name} must be a bytes object")

            tools.validate_int(
                len(parameter), min=0, max=0xFFFF, name=f"{parameter_name} length"
            )
            data += struct.pack(">H", len(parameter))
            data += parameter
        else:
            data += struct.pack(">H", 0)

        return data

    @classmethod
    def make_request(
        cls,
        authentication_task: int,
        *args,
        **kwargs,
        # communication_configuration: Optional[int] = None,
        # certificate_client: Optional[bytes] = None,
        # challenge_client: Optional[bytes] = None,
        # algorithm_indicator: Optional[bytes] = None,
        # certificate_evaluation_id: Optional[int] = None,
        # certificate_data: Optional[bytes] = None,
        # proof_of_ownership_client: Optional[bytes] = None,
        # ephemeral_public_key_client: Optional[bytes] = None,
        # additional_parameter: Optional[bytes] = None,
    ) -> Request:
        tools.validate_int(
            authentication_task, min=0, max=8, name="Authentication Task"
        )
        return Request(
            service=cls,
            subfunction=authentication_task,
            data=RequestData(authentication_task, *args, **kwargs).pack(),
        )

    @staticmethod
    def _extract_byes_parameter(
        response: Response, data: bytes, parameter_name: str
    ) -> bytes:
        if data is not None and len(data) >= 2:
            (parameter_length,) = struct.unpack(">H", data[:2])
        else:
            raise InvalidResponseException(
                response, f"Not enough data for length of {parameter_name}"
            )

        if len(data) >= (2 + parameter_length):
            return data[2 : (2 + parameter_length)]
        else:
            raise InvalidResponseException(
                response,
                f"Not enough data for {parameter_name}."
                f" Parsed length is: {parameter_length}, reset of payload length"
                f" is {len(data) - 2}",
            )

    @classmethod
    def interpret_response(
        cls,
        response: Response,
        standard_version: StandardVersion = StandardVersion.latest(),
    ):
        """
        Populates the response ``service_data`` property with an instance of :class:`DiagnosticSessionControl.ResponseData<udsoncan.services.DiagnosticSessionControl.ResponseData>`

        :param response: The received response to interpret
        :type response: :ref:`Response<Response>`

        :param standard_version: The version of the ISO-14229 (the year). eg. 2006, 2013, 2020
        :type standard_version: int

        :raises InvalidResponseException: If length of ``response.data`` is too short
        """
        return cls._interpret_response(response, standard_version)
